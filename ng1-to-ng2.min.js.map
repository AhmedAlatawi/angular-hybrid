{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///ng1-to-ng2.min.js","webpack:///webpack/bootstrap 9df54dd622b5fc13c815?ebcf","webpack:///./ng1-to-ng2.ts?d367","webpack:///external {\"root\":\"angular\",\"amd\":\"angular\",\"commonjs2\":\"angular\",\"commonjs\":\"angular\"}?1035","webpack:///external {\"root\":\"angular-ui-router\",\"amd\":\"angular-ui-router\",\"commonjs2\":\"angular-ui-router\",\"commonjs\":\"angular-ui-router\"}?3685","webpack:///external {\"root\":\"ui-router-ng2\",\"amd\":\"ui-router-ng2\",\"commonjs2\":\"ui-router-ng2\",\"commonjs\":\"ui-router-ng2\"}?efe2","webpack:///external {\"root\":\"ui-router-rx\",\"amd\":\"ui-router-rx\",\"commonjs2\":\"ui-router-rx\",\"commonjs\":\"ui-router-rx\"}?db19","webpack:///external {\"root\":\"@angular/core\",\"amd\":\"@angular/core\",\"commonjs2\":\"@angular/core\",\"commonjs\":\"@angular/core\"}?3485"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_1__","__WEBPACK_EXTERNAL_MODULE_2__","__WEBPACK_EXTERNAL_MODULE_3__","__WEBPACK_EXTERNAL_MODULE_4__","__WEBPACK_EXTERNAL_MODULE_5__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","uiRouterUpgradeFactory","router","injector","get","ui_router_ng2_1","UIROUTER_MODULE_TOKEN","forEach","applyModuleConfig","applyHybridAdapter","upgradeAdapter","upgradeNg1Provider","upgradeModule","directive","downgradeNg2Component","UIViewNgUpgrade","run","ng1Injector","$uiRouter","mergedInjector","token","ng2NotFoundValue","ng2Injector","has","ng2InjectorResolvable","Resolvable","fromData","NATIVE_INJECTOR_TOKEN","stateRegistry","resolvables","push","config","$stateProvider","$uiRouterProvider","registry","plugin","ui_router_rx_1","UIRouterRx","decorator","ng2LazyLoadBuilder","state","parentFn","views","viewDecl","viewName","$type","isNg2ComponentClass","component","templateProvider","template","$uiViewName","$view","$templateFactory","_pluginapi","_viewConfigFactory","path","Ng2ViewConfig","ng1ViewConfig","angular_ui_router_1","Ng1ViewConfig","Object","assign","ng2ViewConfig","def","Reflect","find","x","core_1","Component","__decorate","decorators","target","key","desc","d","arguments","length","r","getOwnPropertyDescriptor","decorate","i","defineProperty","__metadata","k","v","metadata","__param","paramIndex","value","angular","ng1InitModule","ref","parent","ng1elem","element","nativeElement","data","$cfg","$context","enumerable","$uiView","fqn","Input","String","prototype","selector","viewProviders","provide","UIView","PARENT_INJECT","useValue","Inject","ElementRef","StateRegistry","Ng1ToNg2Module","NgModule","imports","UIRouterModule","declarations","providers","UIRouter","useFactory","deps","Injector","UIROUTER_ROOT_MODULE","multi","concat","_UIROUTER_SERVICE_PROVIDERS","context","uiRouterNgUpgrade","setUpgradeAdapter"],"mappings":"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","file":"ng1-to-ng2.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"), require(\"angular-ui-router\"), require(\"ui-router-ng2\"), require(\"ui-router-rx\"), require(\"@angular/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"ui-router-ng1-to-ng2\", [\"angular\", \"angular-ui-router\", \"ui-router-ng2\", \"ui-router-rx\", \"@angular/core\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ui-router-ng1-to-ng2\"] = factory(require(\"angular\"), require(\"angular-ui-router\"), require(\"ui-router-ng2\"), require(\"ui-router-rx\"), require(\"@angular/core\"));\n\telse\n\t\troot[\"ui-router-ng1-to-ng2\"] = factory(root[\"angular\"], root[\"angular-ui-router\"], root[\"ui-router-ng2\"], root[\"ui-router-rx\"], root[\"@angular/core\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_5__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"), require(\"angular-ui-router\"), require(\"ui-router-ng2\"), require(\"ui-router-rx\"), require(\"@angular/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"ui-router-ng1-to-ng2\", [\"angular\", \"angular-ui-router\", \"ui-router-ng2\", \"ui-router-rx\", \"@angular/core\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ui-router-ng1-to-ng2\"] = factory(require(\"angular\"), require(\"angular-ui-router\"), require(\"ui-router-ng2\"), require(\"ui-router-rx\"), require(\"@angular/core\"));\n\telse\n\t\troot[\"ui-router-ng1-to-ng2\"] = factory(root[\"angular\"], root[\"angular-ui-router\"], root[\"ui-router-ng2\"], root[\"ui-router-rx\"], root[\"@angular/core\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_5__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n\t};\r\n\tvar __metadata = (this && this.__metadata) || function (k, v) {\r\n\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n\t};\r\n\tvar __param = (this && this.__param) || function (paramIndex, decorator) {\r\n\t    return function (target, key) { decorator(target, key, paramIndex); }\r\n\t};\r\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\tvar angular = __webpack_require__(1);\r\n\tvar angular_ui_router_1 = __webpack_require__(2);\r\n\tvar ui_router_ng2_1 = __webpack_require__(3);\r\n\tvar ui_router_rx_1 = __webpack_require__(4);\r\n\tvar core_1 = __webpack_require__(5);\r\n\t/**\r\n\t * Create a ng1 module for the ng1 half of the hybrid application to depend on.\r\n\t *\r\n\t * Example:\r\n\t * let myApp = angular.module('myApp', ['ui.router.upgrade']);\r\n\t */\r\n\texports.upgradeModule = angular.module('ui.router.upgrade', ['ui.router']);\r\n\texports.ng1InitModule = angular.module('ui.router.init');\r\n\t/**\r\n\t * UIViewNgUpgrade is a component bridge from ng1 ui-view to ng2 ui-view\r\n\t *\r\n\t * When a ui-router for ng1 is registering a state it checks if a view's\r\n\t * `component:` is an ng2 Component class. If so, it creates a special ng1 template\r\n\t * which references this component, i.e., <ui-view-ng-upgrade></ui-view-ng-upgrade>\r\n\t *\r\n\t * See that code by searching ng1-to-ng2 source for: \"$stateProvider.decorator\"\r\n\t *\r\n\t * ---\r\n\t *\r\n\t * ng1-to-ng2 component bridge process:\r\n\t *\r\n\t * 1)\r\n\t * When an ng1 template creates a ui-view which is targeted by a ng2 Component,\r\n\t *\r\n\t * ```\r\n\t * <a ui-sref=\"foo\">Go to foo</a>\r\n\t * <div ui-view> <!-- ui-view created in ng1 template -->\r\n\t * </div> <!-- targeted with { component: Ng2RoutedComponent } -->\r\n\t * ```\r\n\t *\r\n\t * the state decorator spits out a custom template.  That template loads this\r\n\t * ng2 Component adapter as a downgraded-to-ng1 directive.\r\n\t *\r\n\t * ```\r\n\t * <a ui-sref=\"foo\">Go to foo</a>\r\n\t * <div ui-view> <!-- decorated template references the downgraded component -->\r\n\t *   <ui-view-ng-upgrade> <!-- downgraded adapter component -->\r\n\t *   </ui-view-ng-upgrade>\r\n\t * </div>\r\n\t * ```\r\n\t *\r\n\t * This downgraded ng2 Component then creates a child UIView (ng2 component)\r\n\t *\r\n\t * ```\r\n\t * <a ui-sref=\"foo\">Go to foo</a>\r\n\t * <div ui-view> <!-- custom template references the downgraded component -->\r\n\t *   <ui-view-ng-upgrade> <!-- ng2 component adapter downgraded to ng1-->\r\n\t *     <ui-view> <!-- pure ng2 ui-view -->\r\n\t*      </ui-view>\r\n\t *   </ui-view-ng-upgrade>\r\n\t * </div>\r\n\t * ```\r\n\t *\r\n\t * which in turn is filled with the routed ng2 component.\r\n\t *\r\n\t * ```\r\n\t * <a ui-sref=\"foo\">Go to foo</a>\r\n\t * <div ui-view> <!-- ng1 ui-view -->\r\n\t *   <ui-view-ng-upgrade> <!-- ng2 component adapter (downgraded to ng1)-->\r\n\t *     <ui-view> <!-- pure ng2 ui-view -->\r\n\t *       <ng2-routed-component> <!-- ng2 component hosted in ng2 ui-view -->\r\n\t *         <h1>ng2 routed component contents</h1>\r\n\t *       </ng2-routed-component>\r\n\t *     </ui-view>\r\n\t *   </ui-view-ng-upgrade>\r\n\t * </div>\r\n\t * ```\r\n\t *\r\n\t * This adapter exposes exposes the parent view context (ParentUIViewInject)\r\n\t * as an ng2 DI Provider, which the nested ng2 UIView requires.\r\n\t *\r\n\t * It gets the ParentUIViewContext information (from the parent ng1 ui-view) by walking\r\n\t * up the DOM and grabbing the .data('$uiView') which the ng1 ui-view directive exposes.\r\n\t */\r\n\tvar UIViewNgUpgrade = (function () {\r\n\t    function UIViewNgUpgrade(ref, parent, registry // access the root state\r\n\t    ) {\r\n\t        // From the ui-view-ng-upgrade component's element ref, walk up the DOM two elements...\r\n\t        // There will first be an ng1 ui-view which hosts this element, and then that ui-view's parent element.\r\n\t        // That (parent) element has access to the proper \"parent viewcontext\"\r\n\t        // The ng2 ui-view component is inside this ui-view-ng-upgrade directive, which is inside the ng1 \"host\" ui-view.\r\n\t        // Both ui-views share the same \"view context\" information (the view's fqn and created-by-state context information)\r\n\t        var ng1elem = angular.element(ref.nativeElement).parent().parent();\r\n\t        // Expose getters on PARENT_INJECT for context (creation state) and fqn (view address)\r\n\t        // These will be used by further nested UIView\r\n\t        Object.defineProperty(parent, \"context\", {\r\n\t            get: function () {\r\n\t                var data = ng1elem['inheritedData']('$uiView');\r\n\t                return (data && data.$cfg) ? data.$cfg.viewDecl.$context : registry.root();\r\n\t            },\r\n\t            enumerable: true\r\n\t        });\r\n\t        Object.defineProperty(parent, \"fqn\", {\r\n\t            get: function () {\r\n\t                var data = ng1elem['inheritedData']('$uiView');\r\n\t                return (data && data.$uiView) ? data.$uiView.fqn : null;\r\n\t            },\r\n\t            enumerable: true\r\n\t        });\r\n\t    }\r\n\t    return UIViewNgUpgrade;\r\n\t}());\r\n\t__decorate([\r\n\t    core_1.Input(),\r\n\t    __metadata(\"design:type\", String)\r\n\t], UIViewNgUpgrade.prototype, \"name\", void 0);\r\n\tUIViewNgUpgrade = __decorate([\r\n\t    core_1.Component({\r\n\t        selector: 'ui-view-ng-upgrade',\r\n\t        template: \"<ui-view [name]=\\\"name\\\"></ui-view>\",\r\n\t        // provide a blank object as PARENT_INJECT.\r\n\t        // The component will add property getters when it is constructed.\r\n\t        viewProviders: [{ provide: ui_router_ng2_1.UIView.PARENT_INJECT, useValue: {} }],\r\n\t    }),\r\n\t    __param(1, core_1.Inject(ui_router_ng2_1.UIView.PARENT_INJECT)),\r\n\t    __metadata(\"design:paramtypes\", [core_1.ElementRef, Object, ui_router_ng2_1.StateRegistry // access the root state\r\n\t    ])\r\n\t], UIViewNgUpgrade);\r\n\texports.UIViewNgUpgrade = UIViewNgUpgrade;\r\n\t/**********************************\r\n\t * Ng2 @NgModule and bootstrap code\r\n\t **********************************/\r\n\t// Register the ng1 DI '$uiRouter' object as an ng2 Provider.\r\n\tfunction uiRouterUpgradeFactory(router, injector) {\r\n\t    var modules = injector.get(ui_router_ng2_1.UIROUTER_MODULE_TOKEN, []);\r\n\t    modules.forEach(function (module) { return ui_router_ng2_1.applyModuleConfig(router, injector, module); });\r\n\t    return router;\r\n\t}\r\n\t/**\r\n\t * This NgModule should be added to the root module of the hybrid app.\r\n\t */\r\n\tvar Ng1ToNg2Module = (function () {\r\n\t    function Ng1ToNg2Module() {\r\n\t    }\r\n\t    return Ng1ToNg2Module;\r\n\t}());\r\n\tNg1ToNg2Module = __decorate([\r\n\t    core_1.NgModule({\r\n\t        imports: [ui_router_ng2_1.UIRouterModule],\r\n\t        declarations: [UIViewNgUpgrade],\r\n\t        providers: [\r\n\t            // ui-router-ng2 code will use the ng1 $uiRouter instance instead of creating its own.\r\n\t            { provide: ui_router_ng2_1.UIRouter, useFactory: uiRouterUpgradeFactory, deps: ['$uiRouter', core_1.Injector] },\r\n\t            { provide: ui_router_ng2_1.UIROUTER_ROOT_MODULE, useValue: {}, multi: true }\r\n\t        ].concat(ui_router_ng2_1._UIROUTER_SERVICE_PROVIDERS, [\r\n\t            {\r\n\t                provide: ui_router_ng2_1.UIView.PARENT_INJECT,\r\n\t                deps: [ui_router_ng2_1.StateRegistry],\r\n\t                useFactory: function (r) {\r\n\t                    return { fqn: null, context: r.root() };\r\n\t                },\r\n\t            },\r\n\t        ]),\r\n\t        exports: [UIViewNgUpgrade, ui_router_ng2_1.UIRouterModule]\r\n\t    })\r\n\t], Ng1ToNg2Module);\r\n\texports.Ng1ToNg2Module = Ng1ToNg2Module;\r\n\t/**\r\n\t * This function applies the ng1-to-ng2 hybrid adapter\r\n\t *\r\n\t * ---\r\n\t *\r\n\t * - expose the ng1 $uiRouter instance to ng2 DI\r\n\t * - downgrade the ng2 UIViewNgUpgrade for use in ng1 templates\r\n\t * - expose the root ng2 Injector as a resolve on the root state\r\n\t * - decorate state `views:` with ng1/ng2 component detection\r\n\t *   when ng1 is detected, use <ui-view-ng-upgrade> adapter directive as template\r\n\t * - register the ng2 ViewConfigFactory\r\n\t * - register the ng1-to-ng2 ViewConfigFactory\r\n\t *   allows both ng1 and ng2 ui-views to activate\r\n\t */\r\n\tfunction applyHybridAdapter(upgradeAdapter) {\r\n\t    // Expose the ng1 DI '$uiRouter' instance as an ng2 Provider.\r\n\t    upgradeAdapter.upgradeNg1Provider('$uiRouter');\r\n\t    // Downgrade the UIViewNgUpgrade ng2 Component to an ng1 directive.\r\n\t    // The directive is used in a (generated) view template by the (host) ng1 ui-router,\r\n\t    // whenever it finds a view configured with a `component: <Ng2ComponentClass>`\r\n\t    exports.upgradeModule.directive(\"uiViewNgUpgrade\", upgradeAdapter.downgradeNg2Component(UIViewNgUpgrade));\r\n\t    exports.upgradeModule.run(['$injector', function (ng1Injector) {\r\n\t            var $uiRouter = ng1Injector.get('$uiRouter');\r\n\t            // Expose a merged ng1/ng2 injector as a Resolvable (on the root state).\r\n\t            // This mimics how ui-router-ng2 exposes the root ng2 Injector, but\r\n\t            // it retrieves from ng1 injector first, then ng2 injector if the token isn't found.\r\n\t            var mergedInjector = {\r\n\t                get: function (token, ng2NotFoundValue) {\r\n\t                    var ng2Injector = ng1Injector.get('ng2.Injector');\r\n\t                    return (ng1Injector.has(token) && ng1Injector.get(token)) || ng2Injector.get(token, ng2NotFoundValue);\r\n\t                }\r\n\t            };\r\n\t            var ng2InjectorResolvable = ui_router_ng2_1.Resolvable.fromData(ui_router_ng2_1.NATIVE_INJECTOR_TOKEN, mergedInjector);\r\n\t            $uiRouter.stateRegistry.root().resolvables.push(ng2InjectorResolvable);\r\n\t        }]);\r\n\t    exports.upgradeModule.config(['$stateProvider', function ($stateProvider) {\r\n\t        }]);\r\n\t    exports.upgradeModule.config(['$uiRouterProvider', function ($uiRouterProvider) {\r\n\t            var registry = $uiRouterProvider.stateRegistry;\r\n\t            /** Applies the `UIRouterRx` plugin for observable states/params */\r\n\t            $uiRouterProvider.plugin(ui_router_rx_1.UIRouterRx);\r\n\t            /** Adds the ng2 `loadChildren` lazy loading decorator */\r\n\t            registry.decorator('lazyLoad', ui_router_ng2_1.ng2LazyLoadBuilder);\r\n\t            /**\r\n\t             * Adds a state decorator which modifies a state's view configuration as it's being registered.\r\n\t             *\r\n\t             * ---\r\n\t             *\r\n\t             * Define a stateProvider `views` builder decorator.\r\n\t             * The decorator first applies the standard views builder function.\r\n\t             * Then it finds any view components which are **actually** a Ng2 Component Class.\r\n\t             * It overwrites that view's config with a ng1-to-ng2 hybrid config.\r\n\t             *\r\n\t             * In place of the template provider, it simply puts a <ui-view-ng-upgrade/> component\r\n\t             * which that provides a ng1 -> ng2 boundary in the component tree.\r\n\t             */\r\n\t            registry.decorator('views', function (state, parentFn) {\r\n\t                var views = parentFn(state);\r\n\t                ui_router_ng2_1.forEach(views, function (viewDecl, viewName) {\r\n\t                    if (viewDecl.$type === 'ng1-to-ng2' || isNg2ComponentClass(viewDecl.component)) {\r\n\t                        // Update the view config.\r\n\t                        // Override default ng1 `component:` behavior (of defining a templateProvider)\r\n\t                        // with a <ui-view-ng-upgrade> adapter directive template\r\n\t                        viewDecl.$type = \"ng1-to-ng2\";\r\n\t                        viewDecl.templateProvider = null;\r\n\t                        viewDecl.template = \"<ui-view-ng-upgrade name='\" + viewDecl.$uiViewName + \"'></ui-view-ng-upgrade>\";\r\n\t                    }\r\n\t                });\r\n\t                return views;\r\n\t            });\r\n\t        }]);\r\n\t    // UI-Router ViewConfig factories take a view declaration object from a state.views: { foo: <ViewDeclaration> }\r\n\t    // and return a runtime config object (a ViewConfig)\r\n\t    exports.upgradeModule.run(['$view', '$templateFactory', function ($view, $templateFactory) {\r\n\t            // Register a ViewConfig factory for views of type `ng2`\r\n\t            $view._pluginapi._viewConfigFactory('ng2', function (path, config) { return new ui_router_ng2_1.Ng2ViewConfig(path, config); });\r\n\t            // Register a ViewConfig factory for views of type `ng1-to-ng2`.\r\n\t            // Returns both an ng1 config and an ng2 config allowing either ng1 or ng2 ui-view components to be targeted.\r\n\t            $view._pluginapi._viewConfigFactory('ng1-to-ng2', function (path, config) {\r\n\t                var ng1ViewConfig = new angular_ui_router_1.Ng1ViewConfig(path, Object.assign({}, config, { $type: 'ng1' }), $templateFactory);\r\n\t                var ng2ViewConfig = new ui_router_ng2_1.Ng2ViewConfig(path, Object.assign({}, config, { $type: 'ng2' }));\r\n\t                return [ng2ViewConfig, ng1ViewConfig];\r\n\t            });\r\n\t        }]);\r\n\t}\r\n\t/** Predicate fn that returns true if an object is a NG2 Component Class */\r\n\tfunction isNg2ComponentClass(def) {\r\n\t    if (typeof def !== 'function')\r\n\t        return false;\r\n\t    return Reflect['getMetadata']('annotations', def)\r\n\t        .find(function (x) { return x instanceof core_1.Component; });\r\n\t}\r\n\texports.isNg2ComponentClass = isNg2ComponentClass;\r\n\t/**\r\n\t * Hybrid apps should import this and call `uiRouterNgUpgrade.setUpgradeAdapter(adapter)`.\r\n\t * This will register the ui-router hybrid adapter code.\r\n\t */\r\n\texports.uiRouterNgUpgrade = {\r\n\t    setUpgradeAdapter: function (upgradeAdapter) {\r\n\t        applyHybridAdapter(upgradeAdapter);\r\n\t    }\r\n\t};\r\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// ng1-to-ng2.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 9df54dd622b5fc13c815","import * as angular from 'angular';\n\nimport { $InjectorLike, Ng1ViewConfig, StateObject, StateProvider } from 'angular-ui-router';\n\nimport {\n  _UIROUTER_SERVICE_PROVIDERS, applyModuleConfig, forEach, NATIVE_INJECTOR_TOKEN, Ng2ViewConfig, Ng2ViewDeclaration,\n  ParentUIViewInject, PathNode, Resolvable, StateRegistry, StatesModule, UIRouter, UIROUTER_MODULE_TOKEN,\n  UIROUTER_ROOT_MODULE, UIRouterModule, UIView, ViewConfig, ViewService, ng2LazyLoadBuilder\n} from 'ui-router-ng2';\n\nimport { UIRouterRx } from \"ui-router-rx\";\n\nimport { Component, ElementRef, Inject, Injector, Input, NgModule } from '@angular/core';\nimport { UpgradeAdapter } from '@angular/upgrade';\n\n/**\n * Create a ng1 module for the ng1 half of the hybrid application to depend on.\n *\n * Example:\n * let myApp = angular.module('myApp', ['ui.router.upgrade']);\n */\nexport let upgradeModule = angular.module('ui.router.upgrade', ['ui.router']);\nexport let ng1InitModule = angular.module('ui.router.init');\n\n/**\n * UIViewNgUpgrade is a component bridge from ng1 ui-view to ng2 ui-view\n *\n * When a ui-router for ng1 is registering a state it checks if a view's\n * `component:` is an ng2 Component class. If so, it creates a special ng1 template\n * which references this component, i.e., <ui-view-ng-upgrade></ui-view-ng-upgrade>\n *\n * See that code by searching ng1-to-ng2 source for: \"$stateProvider.decorator\"\n *\n * ---\n *\n * ng1-to-ng2 component bridge process:\n *\n * 1)\n * When an ng1 template creates a ui-view which is targeted by a ng2 Component,\n *\n * ```\n * <a ui-sref=\"foo\">Go to foo</a>\n * <div ui-view> <!-- ui-view created in ng1 template -->\n * </div> <!-- targeted with { component: Ng2RoutedComponent } -->\n * ```\n *\n * the state decorator spits out a custom template.  That template loads this\n * ng2 Component adapter as a downgraded-to-ng1 directive.\n *\n * ```\n * <a ui-sref=\"foo\">Go to foo</a>\n * <div ui-view> <!-- decorated template references the downgraded component -->\n *   <ui-view-ng-upgrade> <!-- downgraded adapter component -->\n *   </ui-view-ng-upgrade>\n * </div>\n * ```\n *\n * This downgraded ng2 Component then creates a child UIView (ng2 component)\n *\n * ```\n * <a ui-sref=\"foo\">Go to foo</a>\n * <div ui-view> <!-- custom template references the downgraded component -->\n *   <ui-view-ng-upgrade> <!-- ng2 component adapter downgraded to ng1-->\n *     <ui-view> <!-- pure ng2 ui-view -->\n*      </ui-view>\n *   </ui-view-ng-upgrade>\n * </div>\n * ```\n *\n * which in turn is filled with the routed ng2 component.\n *\n * ```\n * <a ui-sref=\"foo\">Go to foo</a>\n * <div ui-view> <!-- ng1 ui-view -->\n *   <ui-view-ng-upgrade> <!-- ng2 component adapter (downgraded to ng1)-->\n *     <ui-view> <!-- pure ng2 ui-view -->\n *       <ng2-routed-component> <!-- ng2 component hosted in ng2 ui-view -->\n *         <h1>ng2 routed component contents</h1>\n *       </ng2-routed-component>\n *     </ui-view>\n *   </ui-view-ng-upgrade>\n * </div>\n * ```\n *\n * This adapter exposes exposes the parent view context (ParentUIViewInject)\n * as an ng2 DI Provider, which the nested ng2 UIView requires.\n *\n * It gets the ParentUIViewContext information (from the parent ng1 ui-view) by walking\n * up the DOM and grabbing the .data('$uiView') which the ng1 ui-view directive exposes.\n */\n@Component({\n  selector: 'ui-view-ng-upgrade',\n  template: `<ui-view [name]=\"name\"></ui-view>`,\n  // provide a blank object as PARENT_INJECT.\n  // The component will add property getters when it is constructed.\n  viewProviders: [ { provide: UIView.PARENT_INJECT, useValue: { } } ],\n})\nexport class UIViewNgUpgrade {\n  // The ui-view's name (or '$default')\n  @Input() private name: string;\n\n  constructor(\n      ref: ElementRef,\n      @Inject(UIView.PARENT_INJECT) parent: ParentUIViewInject,\n      registry: StateRegistry // access the root state\n  ) {\n    // From the ui-view-ng-upgrade component's element ref, walk up the DOM two elements...\n    // There will first be an ng1 ui-view which hosts this element, and then that ui-view's parent element.\n    // That (parent) element has access to the proper \"parent viewcontext\"\n\n    // The ng2 ui-view component is inside this ui-view-ng-upgrade directive, which is inside the ng1 \"host\" ui-view.\n    // Both ui-views share the same \"view context\" information (the view's fqn and created-by-state context information)\n    let ng1elem = angular.element(ref.nativeElement).parent().parent();\n\n    // Expose getters on PARENT_INJECT for context (creation state) and fqn (view address)\n    // These will be used by further nested UIView\n    Object.defineProperty(parent, \"context\", {\n      get: function() {\n        let data = ng1elem['inheritedData']('$uiView');\n        return (data && data.$cfg) ? data.$cfg.viewDecl.$context : registry.root();\n      },\n      enumerable: true\n    });\n\n    Object.defineProperty(parent, \"fqn\", {\n      get: function() {\n        let data = ng1elem['inheritedData']('$uiView');\n        return (data && data.$uiView) ? data.$uiView.fqn : null;\n      },\n      enumerable: true\n    });\n  }\n}\n\n/**********************************\n * Ng2 @NgModule and bootstrap code\n **********************************/\n\n// Register the ng1 DI '$uiRouter' object as an ng2 Provider.\nfunction uiRouterUpgradeFactory(router: UIRouter, injector: Injector) {\n  let modules: StatesModule[] = injector.get(UIROUTER_MODULE_TOKEN, []);\n  modules.forEach(module => applyModuleConfig(router, injector, module));\n  return router;\n}\n\n/**\n * This NgModule should be added to the root module of the hybrid app.\n */\n@NgModule({\n  imports: [UIRouterModule],\n  declarations: [UIViewNgUpgrade],\n  providers: [\n    // ui-router-ng2 code will use the ng1 $uiRouter instance instead of creating its own.\n    { provide: UIRouter, useFactory: uiRouterUpgradeFactory, deps: ['$uiRouter', Injector] },\n\n    { provide: UIROUTER_ROOT_MODULE, useValue: {}, multi: true },\n\n    ..._UIROUTER_SERVICE_PROVIDERS,\n\n    {\n      provide: UIView.PARENT_INJECT,\n      deps: [StateRegistry],\n      useFactory: (r: StateRegistry) => {\n        return { fqn: null, context: r.root() } as ParentUIViewInject\n      },\n    },\n  ],\n  exports: [UIViewNgUpgrade, UIRouterModule]\n}) export class Ng1ToNg2Module {}\n\n/**\n * This function applies the ng1-to-ng2 hybrid adapter\n *\n * ---\n *\n * - expose the ng1 $uiRouter instance to ng2 DI\n * - downgrade the ng2 UIViewNgUpgrade for use in ng1 templates\n * - expose the root ng2 Injector as a resolve on the root state\n * - decorate state `views:` with ng1/ng2 component detection\n *   when ng1 is detected, use <ui-view-ng-upgrade> adapter directive as template\n * - register the ng2 ViewConfigFactory\n * - register the ng1-to-ng2 ViewConfigFactory\n *   allows both ng1 and ng2 ui-views to activate\n */\nfunction applyHybridAdapter(upgradeAdapter: UpgradeAdapter) {\n  // Expose the ng1 DI '$uiRouter' instance as an ng2 Provider.\n  upgradeAdapter.upgradeNg1Provider('$uiRouter');\n\n  // Downgrade the UIViewNgUpgrade ng2 Component to an ng1 directive.\n  // The directive is used in a (generated) view template by the (host) ng1 ui-router,\n  // whenever it finds a view configured with a `component: <Ng2ComponentClass>`\n  upgradeModule.directive(\"uiViewNgUpgrade\", <any> upgradeAdapter.downgradeNg2Component(UIViewNgUpgrade));\n\n  upgradeModule.run(['$injector', (ng1Injector: $InjectorLike) => {\n    let $uiRouter: UIRouter = ng1Injector.get('$uiRouter');\n\n    // Expose a merged ng1/ng2 injector as a Resolvable (on the root state).\n    // This mimics how ui-router-ng2 exposes the root ng2 Injector, but\n    // it retrieves from ng1 injector first, then ng2 injector if the token isn't found.\n    const mergedInjector = {\n      get: function(token: any, ng2NotFoundValue?: any) {\n        let ng2Injector = ng1Injector.get('ng2.Injector');\n        return (ng1Injector.has(token) && ng1Injector.get(token)) || ng2Injector.get(token, ng2NotFoundValue)\n      }\n    };\n\n    let ng2InjectorResolvable = Resolvable.fromData(NATIVE_INJECTOR_TOKEN, mergedInjector);\n    $uiRouter.stateRegistry.root().resolvables.push(ng2InjectorResolvable);\n  }]);\n\n\n  upgradeModule.config(['$stateProvider', ($stateProvider: StateProvider) => {\n  }]);\n\n  upgradeModule.config(['$uiRouterProvider', ($uiRouterProvider: UIRouter) => {\n    let registry = $uiRouterProvider.stateRegistry;\n\n    /** Applies the `UIRouterRx` plugin for observable states/params */\n    $uiRouterProvider.plugin(UIRouterRx);\n\n    /** Adds the ng2 `loadChildren` lazy loading decorator */\n    registry.decorator('lazyLoad', ng2LazyLoadBuilder);\n\n    /**\n     * Adds a state decorator which modifies a state's view configuration as it's being registered.\n     *\n     * ---\n     *\n     * Define a stateProvider `views` builder decorator.\n     * The decorator first applies the standard views builder function.\n     * Then it finds any view components which are **actually** a Ng2 Component Class.\n     * It overwrites that view's config with a ng1-to-ng2 hybrid config.\n     *\n     * In place of the template provider, it simply puts a <ui-view-ng-upgrade/> component\n     * which that provides a ng1 -> ng2 boundary in the component tree.\n     */\n    registry.decorator('views', function(state: StateObject, parentFn: Function) {\n      let views = parentFn(state);\n\n      forEach(views, (viewDecl: any, viewName: string) => {\n        if (viewDecl.$type === 'ng1-to-ng2' || isNg2ComponentClass(viewDecl.component)) {\n          // Update the view config.\n          // Override default ng1 `component:` behavior (of defining a templateProvider)\n          // with a <ui-view-ng-upgrade> adapter directive template\n          viewDecl.$type = \"ng1-to-ng2\";\n          viewDecl.templateProvider = null;\n          viewDecl.template = `<ui-view-ng-upgrade name='${viewDecl.$uiViewName}'></ui-view-ng-upgrade>`;\n        }\n      });\n      return views;\n    });\n  }]);\n\n  // UI-Router ViewConfig factories take a view declaration object from a state.views: { foo: <ViewDeclaration> }\n  // and return a runtime config object (a ViewConfig)\n  upgradeModule.run(['$view', '$templateFactory', ($view: ViewService, $templateFactory) => {\n    // Register a ViewConfig factory for views of type `ng2`\n    $view._pluginapi._viewConfigFactory('ng2', (path: PathNode[], config: Ng2ViewDeclaration) => new Ng2ViewConfig(path, config));\n\n    // Register a ViewConfig factory for views of type `ng1-to-ng2`.\n    // Returns both an ng1 config and an ng2 config allowing either ng1 or ng2 ui-view components to be targeted.\n    $view._pluginapi._viewConfigFactory('ng1-to-ng2', (path: PathNode[], config: Ng2ViewDeclaration) => {\n      let ng1ViewConfig: ViewConfig = <any> new Ng1ViewConfig(<any> path, <any> Object.assign({}, config, { $type: 'ng1'}), $templateFactory);\n      let ng2ViewConfig: ViewConfig = <any> new Ng2ViewConfig(<any> path, <any> Object.assign({}, config, { $type: 'ng2'}));\n\n      return [ ng2ViewConfig, ng1ViewConfig ];\n    });\n  }])\n}\n\n/** Predicate fn that returns true if an object is a NG2 Component Class */\nexport function isNg2ComponentClass(def: any) {\n  if (typeof def !== 'function') return false;\n\n  return Reflect['getMetadata']('annotations', def)\n      .find((x: any) => x instanceof Component);\n}\n\n\n/**\n * Hybrid apps should import this and call `uiRouterNgUpgrade.setUpgradeAdapter(adapter)`.\n * This will register the ui-router hybrid adapter code.\n */\nexport let uiRouterNgUpgrade = {\n  setUpgradeAdapter: function(upgradeAdapter: UpgradeAdapter) {\n    applyHybridAdapter(upgradeAdapter);\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./ng1-to-ng2.ts","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"angular\",\"amd\":\"angular\",\"commonjs2\":\"angular\",\"commonjs\":\"angular\"}\n// module id = 1\n// module chunks = 0 1","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"angular-ui-router\",\"amd\":\"angular-ui-router\",\"commonjs2\":\"angular-ui-router\",\"commonjs\":\"angular-ui-router\"}\n// module id = 2\n// module chunks = 0 1","module.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"ui-router-ng2\",\"amd\":\"ui-router-ng2\",\"commonjs2\":\"ui-router-ng2\",\"commonjs\":\"ui-router-ng2\"}\n// module id = 3\n// module chunks = 0 1","module.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"ui-router-rx\",\"amd\":\"ui-router-rx\",\"commonjs2\":\"ui-router-rx\",\"commonjs\":\"ui-router-rx\"}\n// module id = 4\n// module chunks = 0 1","module.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"@angular/core\",\"amd\":\"@angular/core\",\"commonjs2\":\"@angular/core\",\"commonjs\":\"@angular/core\"}\n// module id = 5\n// module chunks = 0 1"],"sourceRoot":""}